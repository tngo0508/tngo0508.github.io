---
layout: single
title: "Problem of The Day: Remove Duplicates from Sorted List II"
date: 2024-3-8
toc: true
toc_label: "Page Navigation"
toc_sticky: true
show_date: true
tags:
  - Daily Coding
---

## Problem Statement

[![problem-82](/assets/images/2024-03-07_14-14-50-problem-82.png)](/assets/images/2024-03-07_14-14-50-problem-82.png)

## O(n) Space Approach

### Intuition

My initial thought is to iterate through the list, keeping track of the frequency of each node's value. This frequency information can then be used to identify and delete duplicate nodes.

### Approach

- Initialize a dummy node to simplify handling edge cases.
- Iterate through the list and count the frequency of each node's value using a defaultdict.
- Iterate through the list again. If a node's value has a frequency greater than 1, skip it and update the pointers to remove it from the list.
- Return the modified list.

### Complexity

- Time complexity:
  O(n), where n is the number of nodes in the linked list. We process each node twice, once for counting frequencies and once for removing duplicates.

- Space complexity:
  O(n), as we use a defaultdict to store the frequency of each node's value.

### Code

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(-101, head)
        prev = dummy
        freq = defaultdict(int)
        curr = head
        while curr:
            freq[curr.val] += 1
            curr = curr.next

        curr = head
        while curr:
            if freq[curr.val] > 1:
                curr = curr.next
                prev.next = None
            else:
                prev.next = curr
                prev = curr
                curr = curr.next

        return dummy.next
```
