---
layout: single
title: "Azure DevOps: Azure-pipeline templates"
date: 2024-8-21
show_date: true
toc: true
toc_label: "Page Navigation"
toc_sticky: true
classes: wide
tags:
  - Azure
---

In the past,  we explored how to create simple CICD pipeline. Then, we went through the steps to create the CICD pipeline for multiple release sites. In this journal, we will take a leap to do more advantage azure devops by using [templates](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops&pivots=templates-includes).

## Motivation

Previously, we created an `azure-pipeline.yaml` that contains all the stages, jobs, and steps. This is fine for a simple project and only if we just want to deploy a site. But, the pipeline yaml will becomes larger when we keep adding more instructions on the pipeline or introduce new stages, jobs or steps. With that said, we can simplify this process by utilizing the template that Azure DevOps Services provides us. This helps us to reuse the code and cleanup our pipeline.

## Recap

This was our `azure-pipeline.yaml` from previous journal.

```yaml
# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
- main
- azure-pipelines

variables:
  solution: '**/*.sln'
  buildPlatform: 'x64'
  buildConfiguration: 'Release'

stages:
  - stage: BuildFinalRuleDAC
    jobs:
      - job: Build
        pool:
          name: default
          demands:
          - Agent.Name -equals agent1
          - Agent.Version -gtVersion 2.153.1
        steps:
        - task: NuGetCommand@2
          inputs:
            command: 'restore'
            restoreSolution: '**/*.sln'
            feedsToUse: 'select'
        - task: UseDotNet@2
          inputs:
            packageType: 'sdk'
            version: '6.x'
        - task: DotNetCoreCLI@2
          inputs:
            command: 'restore'
            projects: 'FinalRuleDAC/FinalRuleDAC.csproj'
        - task: DotNetCoreCLI@2
          inputs:
            command: 'build'
            projects: 'FinalRuleDAC/FinalRuleDAC.csproj'
            configuration: '$(buildConfiguration)'
  - stage: BuildProviderDMS
    dependsOn: BuildFinalRuleDAC
    jobs:
      - job: Build
        pool:
          name: default
          demands:
          - Agent.Name -equals agent1
          - Agent.Version -gtVersion 2.153.1
        steps:
        - task: DotNetCoreCLI@2
          inputs:
            command: 'restore'
            projects: 'ProviderDMS/ProviderDMS.csproj'
        - task: DotNetCoreCLI@2
          inputs:
            command: 'build'
            projects: 'ProviderDMS/ProviderDMS.csproj'
            configuration: '$(buildConfiguration)'
  - stage: CreateProviderDMSArtifact
    dependsOn: BuildProviderDMS
    jobs:
    - job: CreateArtifact
      pool:
        name: default
        demands:
        - Agent.Name -equals agent1
        - Agent.Version -gtVersion 2.153.1
      steps:
      - task: UseDotNet@2
        inputs:
          packageType: 'sdk'
          version: '6.x'
      - task: DotNetCoreCLI@2
        inputs:
          command: 'publish'
          projects: 'ProviderDMS/ProviderDMS.csproj'
          zipAfterPublish: false
          arguments: '--configuration $(buildConfiguration) --runtime win-x64 --self-contained --output $(Build.ArtifactStagingDirectory) /p:PublishReadyToRun=true'
      - task: DownloadSecureFile@1
        inputs:
          secureFile: 'appsettings.stage.json'
      - task: PowerShell@2
        inputs:
          targetType: inline
          script: Copy-Item -Path "$(Agent.TempDirectory)/appsettings.stage.json" -Destination "$(Build.ArtifactStagingDirectory)/ProviderDMS/appsettings.json"
        displayName: 'Copy stage appsettings'
      - task: DownloadSecureFile@1
        inputs:
          secureFile: 'site.stage.css'
      - task: PowerShell@2
        inputs:
          targetType: inline
          script: Copy-Item -Path "$(Agent.TempDirectory)/site.stage.css" -Destination "$(Build.ArtifactStagingDirectory)/ProviderDMS/wwwroot/css/site.css"
        displayName: 'Copy stage site.css'
      - task: PublishBuildArtifacts@1
        displayName: 'Publish Artifact'
        inputs:
          PathtoPublish: '$(build.artifactstagingdirectory)'
          ArtifactName: publishStage
        condition: succeededOrFailed()
```

As you can see, it's very long and hard to manage. Let's break it down into smaller pieces and apply the [stage template](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops&pivots=templates-includes#stage-reuse)

## Stage Template

Let's create the build.yaml template first. This is how it looks.

```yaml
stages:
  - stage: BuildFinalRuleDAC
    displayName: DAC
    jobs:
      - job: Build
        pool:
          name: default
          demands:
          - Agent.Name -equals agent1
          - Agent.Version -gtVersion 2.153.1
        steps:
        - script: |
            echo "System.DefaultWorkingDirectory: $(System.DefaultWorkingDirectory)"
          displayName: 'Show System.DefaultWorkingDirectory'
        - task: DotNetCoreCLI@2
          inputs:
            command: 'restore'
            projects: 'FinalRuleDAC/FinalRuleDAC.csproj'
        - task: DotNetCoreCLI@2
          inputs:
            command: 'build'
            projects: 'FinalRuleDAC/FinalRuleDAC.csproj'
            configuration: '$(buildConfiguration)'
  - stage: BuildProviderApi
    displayName: ProviderApi(KDXTi)
    dependsOn: BuildFinalRuleDAC
    jobs:
      - job: Build
        pool:
          name: default
          demands:
          - Agent.Name -equals agent1
          - Agent.Version -gtVersion 2.153.1
        steps:
        - task: DotNetCoreCLI@2
          inputs:
            command: 'restore'
            projects: 'ProviderApi/ProviderApi.csproj'
        - task: DotNetCoreCLI@2
          inputs:
            command: 'build'
            projects: 'ProviderApi/ProviderApi.csproj'
            configuration: '$(buildConfiguration)'
  - stage: BuildProviderDMS
    displayName: ProviderDMS(Web UI)
    dependsOn: BuildFinalRuleDAC
    jobs:
      - job: Build
        pool:
          name: default
          demands:
          - Agent.Name -equals agent1
          - Agent.Version -gtVersion 2.153.1
        steps:
        - task: DotNetCoreCLI@2
          inputs:
            command: 'restore'
            projects: 'ProviderDMS/ProviderDMS.csproj'
        - task: DotNetCoreCLI@2
          inputs:
            command: 'build'
            projects: 'ProviderDMS/ProviderDMS.csproj'
            configuration: '$(buildConfiguration)'
```

Then, we create the publish template for Web API and Blazor project. In my example, `DAC` is the data access layer that we wrote in order to query the data from SQL server database. `ProviderApi` is a web api services for validating the records based on some particular business logic. `ProviderDMS` is our web server Blazor project.

Furthermore, these are the example of our `publishProviderApi.yaml` and `pubishProviderDMS.yaml`

```yaml
# publishProviderApi.yaml
parameters:
  dependsOn: []
  version: ''

stages:
- stage: ${{parameters.version}}_CreateProviderApiArtifact
  displayName: ProviderApi(KDXTi) Artifact (${{parameters.version}})
  dependsOn: ${{parameters.dependsOn}}
  jobs:
  - job: ${{parameters.version}}_CreateArtifact
    pool:
      name: default
      demands:
      - Agent.Name -equals agent1
      - Agent.Version -gtVersion 2.153.1
    steps:
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.x'
    - task: DotNetCoreCLI@2
      inputs:
        command: 'publish'
        projects: 'ProviderApi/ProviderApi.csproj'
        publishWebProjects: false
        zipAfterPublish: false
        arguments: '--configuration $(buildConfiguration) --runtime win-x64 --self-contained --output $(Build.ArtifactStagingDirectory)/${{parameters.version}} /p:PublishReadyToRun=true'
    # - task: DownloadSecureFile@1
    #   inputs:
    #     secureFile: 'appsettings.${{parameters.version}}.providerapi.json'
    # - task: PowerShell@2
    #   inputs:
    #     targetType: inline
    #     script: Copy-Item -Path "$(Agent.TempDirectory)/appsettings.${{parameters.version}}.providerapi.json" -Destination "$(Build.ArtifactStagingDirectory)/${{parameters.version}}/ProviderApi/appsettings.json"
    #   displayName: 'Copy ${{parameters.version}} ProviderApi appsettings'
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Artifact'
      inputs:
        PathtoPublish: '$(build.artifactstagingdirectory)/${{parameters.version}}'
        ArtifactName: publish${{parameters.version}}
      condition: succeededOrFailed()
```

```yaml
# pubishProviderDMS.yaml
parameters:
  dependsOn: []
  version: ''

stages:
- stage: ${{parameters.version}}_CreateProviderDMSArtifact
  displayName: ProviderDMS Artifact (${{parameters.version}})
  dependsOn: ${{parameters.dependsOn}}
  jobs:
  - job: ${{parameters.version}}_CreateArtifact
    pool:
      name: default
      demands:
      - Agent.Name -equals agent1
      - Agent.Version -gtVersion 2.153.1
    steps:
    - script: |
        echo "Build.ArtifactStagingDirectory: $(Build.ArtifactStagingDirectory)"
      displayName: 'Show Build.ArtifactStagingDirectory'
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '6.x'
    - task: DotNetCoreCLI@2
      inputs:
        command: 'publish'
        projects: 'ProviderDMS/ProviderDMS.csproj'
        zipAfterPublish: false
        arguments: '--configuration $(buildConfiguration) --runtime win-x64 --self-contained --output $(Build.ArtifactStagingDirectory)/${{parameters.version}} /p:PublishReadyToRun=true'
    # - task: DownloadSecureFile@1
    #   inputs:
    #     secureFile: 'appsettings.${{parameters.version}}.providerdms.json'
    # - task: PowerShell@2
    #   inputs:
    #     targetType: inline
    #     script: Copy-Item -Path "$(Agent.TempDirectory)/appsettings.${{parameters.version}}.providerdms.json" -Destination "$(Build.ArtifactStagingDirectory)/${{parameters.version}}/ProviderDMS/appsettings.json"
    #   displayName: 'Copy ${{parameters.version}} appsettings'
    - task: DownloadSecureFile@1
      inputs:
        secureFile: 'site.${{parameters.version}}.css'
    - task: PowerShell@2
      inputs:
        targetType: inline
        script: Copy-Item -Path "$(Agent.TempDirectory)/site.${{parameters.version}}.css" -Destination "$(Build.ArtifactStagingDirectory)/${{parameters.version}}/ProviderDMS/wwwroot/css/site.css"
      displayName: 'Copy ${{parameters.version}} site.css'
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Artifact'
      inputs:
        PathtoPublish: '$(build.artifactstagingdirectory)/${{parameters.version}}'
        ArtifactName: publish${{parameters.version}}
      condition: succeededOrFailed()
```

Note: as we observe from the information above, there are parameters being used in these templates. The rationale reason is that we have three different sites that need to be deployed (Stage, MHP, and SUD). Each site uses the same source code but requires different configuration in `appsettings.json`. Therefore, in stead of dumping al the instructions (e.g., jobs, tasks, and steps) into a giant pipeline. We could leverage the [template parameters](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/template-parameters?view=azure-devops) and [variables](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops&pivots=templates-includes#variable-templates-with-parameter) to help us achieve the goal.


## Main Build Pipeline

With the above setup, we can a cleaner and shorter version of `azure-pipeline.yaml` which looks like the following.

```yaml
# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
- develop

variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'

stages:
  - template: cicd-templates/build.yaml
  - template: cicd-templates/publishProviderDMS.yaml
    parameters:
      dependsOn: 'BuildProviderDMS'
      version: 'stage'
  - template: cicd-templates/publishProviderApi.yaml
    parameters:
      dependsOn: 'stage_CreateProviderDMSArtifact'
      version: 'stage'
  - template: cicd-templates/publishProviderDMS.yaml
    parameters:
      dependsOn: 'stage_CreateProviderApiArtifact'
      version: 'mhp'
  - template: cicd-templates/publishProviderApi.yaml
    parameters:
      dependsOn: 'mhp_CreateProviderDMSArtifact'
      version: 'mhp'
  - template: cicd-templates/publishProviderDMS.yaml
    parameters:
      dependsOn: 'mhp_CreateProviderApiArtifact'
      version: 'sud'
  - template: cicd-templates/publishProviderApi.yaml
    parameters:
      dependsOn: 'sud_CreateProviderDMSArtifact'
      version: 'sud'
```

## File Transform

We are not done here yet since when we deploy the code, it will use the same `appsettings.json` that we have on our local. In order to replace the configurations inside `**/*.json` files. We could do one of the two ways:

1. Secure Files
2. Variable Groups and JSON variable subsitution in Release Pipeline

### Secure Files

To use this method, we first need to prepare all the `appsettings.<version>*.json` that we need, so we can download and replace with the one in our artifacts.

![secure-file](/assets/images/secure-files-8-21.png)

Then, in our template yaml, we could use this powershell command to perform the replacements.

```yaml
- task: DownloadSecureFile@1
  inputs:
    secureFile: 'appsettings.${{parameters.version}}.providerdms.json'
- task: PowerShell@2
  inputs:
    targetType: inline
    script: Copy-Item -Path "$(Agent.TempDirectory)/appsettings.${{parameters.version}}.providerdms.json" -Destination "$(Build.ArtifactStagingDirectory)/${{parameters.version}}/ProviderDMS/appsettings.json"
  displayName: 'Copy ${{parameters.version}} appsettings'
```

With this approach, after the artifact is created, the `appsettings.json` will be replaced with the content of `appsetting.json` which we put inside the secure files.

### JSON variable subsitution

A more elegant approach is to define the variable group for each release stage. This is called [File Transform & Variable Subsitution Options](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/file-transform-v2?view=azure-pipelines) in release pipeline. The Azure DevOps Services is smart enough to find the key-value pairs that we want to replace inside `appsettings.json` if we are able to provide it the defined variable group with the exact keys.

First, let's create variable groups like followings.

![variable-group](/assets/images/variable-groups-cicd.png)

![mhp](/assets/images/variable-groups-cicd-mhp.png)

![stage](/assets/images/stage-variable-group.png)

Make sure that these defined variables should match with the one inside our `appsettings.json` located in local development.

For example, this is my `appsettings.json` for the above variables.

![example-appsettings](/assets/images/provider-dms-appsetting.png)

Then, in the release pipeline, we instruct the Azure DevOps Service to look for `appsettings.json` using wildcard or absolute/relative path to the appsetting.

![release-cicd](/assets/images/release-pipeline-setting.png)

Last and not least, we also need to make sure to tell Azure applies the correct appsettings for correct stage in the release pipeline. This is called scope in the release pipeline.

For instance, this is how I set up my release pipeline variable group.

![scope](/assets/images/setup-scope-vargrp.png)

## Conclusion

That's it. Now we have learned how to separate our main pipeline using template. Also, we have gained the knowledge how to replace the configuration or *.json file with Secure Files and Variable Groups.