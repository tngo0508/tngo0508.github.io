---
layout: single
title: "Problem of The Day: Binary Search Tree to Greater Sum Tree"
date: 2024-6-24
toc: true
toc_label: "Page Navigation"
toc_sticky: true
show_date: true
tags:
  - Problem of The Day
---

## Problem Statement

![1038](/assets/images/2024-06-24_18-47-03-problem-1038.png)

## Intuition

My first thought was to leverage an in-order traversal to accumulate the values of the nodes in a list. Then, by reversing this list, I could transform it into a format where I can easily compute the cumulative sums needed for converting a Binary Search Tree (BST) into a Greater Sum Tree (GST).

## Approach

1. Traverse the tree in in-order and collect the nodes in a list.
2. Reverse the list to get the nodes in descending order.
3. Iterate through the reversed list and update each node’s value to be the sum of its value and all previously visited nodes’ values.

## Complexity

- Time complexity:
  $$O(n)$$ because we visit each node once during the traversal and the summing process.

- Space complexity:
  $$O(n)$$ due to the extra space used for the list to store the nodes during the traversal.

## Code

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def bstToGst(self, root: TreeNode) -> TreeNode:
        temp = []
        def helper(node):
            if not node:
                return
            helper(node.left)
            temp.append(node)
            helper(node.right)

        helper(root)
        temp.reverse()
        for i in range(1, len(temp)):
            temp[i].val += temp[i - 1].val
        return root
```
