---
layout: single
title: "Problem of the Day: N-Queens"
date: 2023-12-25
toc: true
toc_label: "Page Navigation"
toc_sticky: true
tags:
  - Top 100 Liked
  - Problem of the Day
---
Today, I continue grinding the Top 100 Liked List on Leet Code. I encountered a classic and hard problem about Backtrack topic again. This is called the [N-Queens](https://leetcode.com/problems/n-queens/description/?envType=study-plan-v2&envId=top-100-liked). Unlike the other backtrack problems that I have been solving. This problem seems intimidating at first look. It is actually not bad at all, but it does require a lot of tuning on my end to make my submission gets accepted by Leet Code Judge System. To be honest, even though I already tried to solve this multiple times, I still did not get it right on the first implementation. I had to spend a lot of time to fine-tune my logic and look at the trick on the Editorial tab for the logic of checking diagonal and anti-diagonal. I will explain it in this post, so stay tuned. 

# My Explanation and Approach
The idea to solve this problem is fairly simple if you already knew the basic of backtrack. Basically, we just need to go through the entire problem space to try different states of the chess `board`. That means that we are going to start at the very first cell in our chess `board` which is at `[0, 0]` or `column = 0` and `row = 0`. After we place a Queen at a cell. This means the entire row, entire column, and entire diagonals that are related to this cell will be banned from picking. The other queens could not be placed on these banned cells due to the rules of the chess, otherwise they would be captured by the previously placed queen. The checking logic for entire row and entire column are pretty straight forward. Once we place the Queen at a certain cell, then the entire row and entire column related to that cell should not be used for the next candidate.

For example, if I have place the cell at `[0][0]`, `row = 0` and `col = 0` are banned from picking

| i | 0 | 1 | 2 |
|---|---|---|---|
|0|Q|x|x|
|1|x|.|.|
|2|x|.|.|

However, the diagonal is a bit tricky. At first I were not aware of the trick to check for diagonal and anti-diagonal. My naive logic is to check on four directions of a cell (North-East, North-West, South-East, South-West). The logic is convoluted but my solution does manage to bypass the basic test cases.

After reading through the discussion and Editorial, I learned a trick to check for diagonals. The idea is that the diagonals are shared the same values if we apply this formula `row - col`. On the other hands, the anti-diagonal or reverse diagonal will be calculated as `col - row`.

For instance, look the example of the board below. We see that the diagonal `[0][1]` and `[1][2]` share the same value which is `1`

| i | 0 | 1 | 2 | 3 |
|---|---|---|---|---|
|0|0|1|2|3| 
|1|-1|0|1|2|
|2|-2|-1|0|1|
|3|-3|-2|-1|0|

After figuring the checking, the subsequent step is just calling the `backtrack` recursively to place the next queen and check for valid candidate to add the final solution

# Backtracking Template
This is the information that I took from Leet Code. I found it very useful and helpful to me when I ran into any backtrack problems. I suggest to memorize this template and apply it into any backtrack problems that you see. It might come in handy when you need it. 
```python
def backtrack(candidate):
    if find_solution(candidate):
        output(candidate)
        return
    
    # iterate all possible candidates.
    for next_candidate in list_of_candidates:
        if is_valid(next_candidate):
            # try this partial candidate solution
            place(next_candidate)
            # given the candidate, explore further.
            backtrack(next_candidate)
            # backtrack
            remove(next_candidate)
```

# My Naive Solution
Below is my algorithm when I first attempted to solve this problem.
```python
def print_table(state, n):
  for row in range(n):
    for col in range(n):
      if [row, col] in state:
        print('X', end=" ")
      else:
        print('*', end=" ")
    print("")


def valid(row, col, state, n):
  not_valid_cell = set()
  for r, c in state:
    rr, cc = r, c
    while rr + 1 < n and cc + 1 < n:
      rr += 1
      cc += 1
      not_valid_cell.add((rr, cc))
    rr, cc = r, c
    while rr - 1 >= 0 and cc - 1 >= 0:
      rr -= 1
      cc -= 1
      not_valid_cell.add((rr, cc))
    rr, cc = r, c
    while rr - 1 >= 0 and cc + 1 < n:
      rr -= 1
      cc += 1
      not_valid_cell.add((rr, cc))
    rr, cc = r, c
    while rr + 1 < n and cc - 1 >= 0:
      rr += 1
      cc -= 1
      not_valid_cell.add((rr, cc))

  for r, c in state:
    for i in range(n):
      not_valid_cell.add((r, i))
      not_valid_cell.add((i, c))

  if (row, col) in not_valid_cell:
    return False
  
  return True

def helper(n, result, row, state):
  if row > n:
    return
  if n == len(state):
    result[0] += 1
    return

  for col in range(n):
    if valid(row, col, state, n):
      state.append([row, col])
      helper(n, result, row + 1, state)
      state.pop()


def solve_n_queens(n):
  result = [0]
  helper(n, result, 0, [])
  return result[0]
```

# Brute Force Solution
Below is my brute force solution when I attempted to solve it today. Instead of using the spaghetti code that I implemented above. I tried to clean up the code and come up with this solution. Even though, it reached the hard limit on time. But I feel it is easy to follow compared my naive approach above. I broke the logic into different helper functions to ease out the implementation. In additionally, I used the axillary arrays to help me track the banned rows, cols, and diagonals. This way my algorithm would not spend time checking the valid cells or state constantly. 
```python
# time limit exceeded
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def check_row(c, cols):
            return c not in cols
        
        def check_col(r, rows):
            return r not in rows
        
        def check_diagonal(r, c, diagonal, rev_diagonal):
            return (c - r) not in diagonal and (c + r) not in rev_diagonal 

        def is_valid(r, c, diagonal, rev_diagonal, cols, rows):
            return check_row(c, cols) and check_col(r, rows) and check_diagonal(r, c, diagonal, rev_diagonal)

        def backtrack(n, n_queens, board, result, diagonal, rev_diagonal, cols, rows):
            if n_queens == 0:
                candidate = ["".join(x) for x in board]
                if candidate not in result:
                    result.append(["".join(x) for x in board])
                return

            for i in range(n):
                for j in range(n):
                    if is_valid(i, j, diagonal, rev_diagonal, cols, rows):
                        board[i][j] = 'Q'
                        diagonal.append(j-i)
                        rev_diagonal.append(i+j)
                        rows.append(i)
                        cols.append(j)

                        backtrack(n, n_queens - 1, board, result, diagonal, rev_diagonal, cols, rows)

                        diagonal.pop()
                        rev_diagonal.pop()
                        rows.pop()
                        cols.pop()
                        board[i][j] = '.'

        
        board = [['.'] * n for _ in range(n)] # create the board
        result = []
        backtrack(n, n, board, result, [], [], [], [])
        return result
```
# Attempt to optimize the Brute Force Solution
I attempted to optimize my brute force solution above by replacing the axillary array or list with a bunch of `set()`. By using the `set()` data structure, I thought it would reduce my time efficiency. But, this still hit the Time Limit Exceeded issue. This tells me that I need to improve my algorithm further.

```python
# Still hitting the Time Limit Exceeded
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def check_row(c, cols):
            return c not in cols
        
        def check_col(r, rows):
            return r not in rows
        
        def check_diagonal(r, c, diagonal, rev_diagonal):
            return (c - r) not in diagonal and (c + r) not in rev_diagonal 

        def is_valid(r, c, diagonal, rev_diagonal, cols, rows):
            return check_row(c, cols) and check_col(r, rows) and check_diagonal(r, c, diagonal, rev_diagonal)

        def backtrack(n, n_queens, board, result, diagonal, rev_diagonal, cols, rows):
            if n_queens == 0:
                candidate = tuple("".join(x) for x in board)
                if candidate not in result:
                    result.add(candidate)
                return

            for i in range(n):
                for j in range(n):
                    if is_valid(i, j, diagonal, rev_diagonal, cols, rows):
                        board[i][j] = 'Q'
                        diagonal.add(j - i)
                        rev_diagonal.add(i + j)
                        rows.add(i)
                        cols.add(j)

                        backtrack(n, n_queens - 1, board, result, diagonal, rev_diagonal, cols, rows)

                        diagonal.remove(j - i)
                        rev_diagonal.remove(i + j)
                        rows.remove(i)
                        cols.remove(j)
                        board[i][j] = '.'

        
        board = [['.'] * n for _ in range(n)]
        result = set()
        backtrack(n, n, board, result, set(), set(), set(), set())
        return [list(candidate) for candidate in result]
```
# Optimized Solution
Based on my intuition, I realized that I had generated the same potential candidate multiple times due to the nested `for-loop`. In fact, I did not need to go through double `for-loop` because eventually it would end up generate the same valid state of the chess `board`. Instead, I refined my logic by modifying it to go through each column only and passed the row as the parameter for the next `backtrack` function call. It helped to reduce my time efficiency significantly because I was no longer generate the duplicate state or candidate anymore. I could safely remove the check for the base case in the following snippet code
```
if n_queens == 0:
    candidate = tuple("".join(x) for x in board)
    if candidate not in result: # no longer need this logic
        result.add(candidate)
    return
```
And here is my optimized solution.
```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def check_row(c, cols):
            return c not in cols
        
        def check_col(r, rows):
            return r not in rows
        
        def check_diagonal(r, c, diagonal, rev_diagonal):
            return (c - r) not in diagonal and (c + r) not in rev_diagonal 

        def is_valid(r, c, diagonal, rev_diagonal, cols, rows):
            return check_row(c, cols) and check_col(r, rows) and check_diagonal(r, c, diagonal, rev_diagonal)

        def backtrack(i, n, n_queens, board, result, diagonal, rev_diagonal, cols, rows):
            if n_queens == 0:
                candidate = tuple("".join(x) for x in board)
                result.add(candidate)
                return

            for j in range(n):
                if is_valid(i, j, diagonal, rev_diagonal, cols, rows):
                    board[i][j] = 'Q'
                    diagonal.add(j - i)
                    rev_diagonal.add(i + j)
                    rows.add(i)
                    cols.add(j)

                    backtrack(i + 1, n, n_queens - 1, board, result, diagonal, rev_diagonal, cols, rows)

                    diagonal.remove(j - i)
                    rev_diagonal.remove(i + j)
                    rows.remove(i)
                    cols.remove(j)
                    board[i][j] = '.'

        
        board = [['.'] * n for _ in range(n)]
        result = set()
        backtrack(0, n, n, board, result, set(), set(), set(), set())
        return [list(candidate) for candidate in result]
```

# Leet Code Solution
```python
class Solution:
    def solveNQueens(self, n):
        # Making use of a helper function to get the
        # solutions in the correct output format
        def create_board(state):
            board = []
            for row in state:
                board.append("".join(row))
            return board
        
        def backtrack(row, diagonals, anti_diagonals, cols, state):
            # Base case - N queens have been placed
            if row == n:
                ans.append(create_board(state))
                return

            for col in range(n):
                curr_diagonal = row - col
                curr_anti_diagonal = row + col
                # If the queen is not placeable
                if (col in cols 
                      or curr_diagonal in diagonals 
                      or curr_anti_diagonal in anti_diagonals):
                    continue

                # "Add" the queen to the board
                cols.add(col)
                diagonals.add(curr_diagonal)
                anti_diagonals.add(curr_anti_diagonal)
                state[row][col] = "Q"

                # Move on to the next row with the updated board state
                backtrack(row + 1, diagonals, anti_diagonals, cols, state)

                # "Remove" the queen from the board since we have already
                # explored all valid paths using the above function call
                cols.remove(col)
                diagonals.remove(curr_diagonal)
                anti_diagonals.remove(curr_anti_diagonal)
                state[row][col] = "."

        ans = []
        empty_board = [["."] * n for _ in range(n)]
        backtrack(0, set(), set(), set(), empty_board)
        return ans
```

