---
layout: single
title: "Problem of The Day: Maximum Score Words Formed by Letters"
date: 2024-5-23
toc: true
toc_label: "Page Navigation"
toc_sticky: true
show_date: true
tags:
  - Problem of The Day
---

## Problem Statement

![1255](/assets/images/2024-05-23_21-05-58-1255.png)

## Intuition

To solve this problem, the goal is to maximize the score of words we can form using given letters. Each word has a score, and we can only use each letter a limited number of times. This problem can be approached using a combination of backtracking and bit manipulation to explore all possible combinations of words efficiently.

## Approach

Word Scoring: First, we compute the score for each word individually if it can be formed with the given letters. This is done by checking if the word can be formed with the available letters and summing up the scores for the letters in the word.

Depth-First Search (DFS): We use DFS to explore all possible combinations of words that can be formed. For each combination, we check if the words can be formed with the available letters and update the maximum score if the current combination yields a higher score.

Backtracking: During the DFS, we use backtracking to explore both the scenarios of including a word in the current combination and not including it. This ensures that all possible combinations are considered.

Validation: We validate if a word can be formed with the remaining letters at each step of the DFS to ensure we are only considering valid combinations.

## Complexity

- Time complexity:
  O(2^n) where n is the number of words. This is because we are considering all subsets of the words

- Space complexity:
  O(n) where n is the depth of the recursion stack used for DFS

## Code

```python
class Solution:
    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:
        word_score = defaultdict(int)
        for word in words:
            curr_score = 0
            counter = Counter(letters)
            for c in word:
                counter[c] -= 1
                if counter[c] < 0:
                    curr_score = 0
                    break
                else:
                    index = ord(c) - ord('a')
                    curr_score += score[index]

            word_score[word] = curr_score

        self.res = 0
        counter = Counter(letters)

        def isValid(word):
            letter_freq = Counter(word)
            for c in word:
                if letter_freq[c] > counter[c] or c not in counter:
                    return False
            return True

        def dfs(i, curr, curr_score, word_list):
            if i == len(word_list):
                return
            if isValid(curr):
                self.res = max(self.res, curr_score)
            if i + 1 < len(word_list):
                dfs(i + 1, curr + word_list[i + 1], curr_score + word_score[word_list[i + 1]], word_list)
            dfs(i + 1, curr, curr_score, word_list)

        for i in range(len(words)):
            words[i], words[0] = words[0], words[i]
            dfs(0, words[0], word_score[words[0]], words)
            words[i], words[0] = words[0], words[i]


        return self.res


```
